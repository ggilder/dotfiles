#echo "=> Loading `pwd`/prompt"
# Prompts ----------------------------------------------------------
# export PS1="\[${COLOR_GREEN}\]\w > \[${COLOR_NC}\]"	 # Primary prompt with only a path	
# export PS1="\[${COLOR_RED}\]\w > \[${COLOR_NC}\]"	 # Primary prompt for root user, to highlight when you're logged in as root
# export PS1="\[${COLOR_GRAY}\]\u@\h \[${COLOR_GREEN}\]\w > \[${COLOR_NC}\]"	# Primary prompt with user, host, and path 

#git command prompt http://effectif.com/git/config
if [[ -e ~/src/git/contrib/completion/git-completion.bash ]]; then
	. ~/src/git/contrib/completion/git-completion.bash
else
function __git_ps1() {
		local b="$(git symbolic-ref HEAD 2>/dev/null)";
		if [ -n "$b" ]; then
			printf "(%s)" "${b##refs/heads/}";
		fi
	}
fi

function parse_svn_repository_root() {
	if [ -d ".svn" ]; then
		svn info 2>/dev/null | sed -ne 's#^Repository Root: ##p'
	fi
}

function parse_svn_url() {
	if [ -d ".svn" ]; then
		svn info 2>/dev/null | sed -ne 's#^URL: ##p' | sed -e 's#^'"$(parse_svn_repository_root)"'##g' | egrep -o '(tags|branches)/[^/]+|trunk' | egrep -o '[^/]+$' | awk '{print $1}'
	fi
}

function parse_svn_revision() {
	if [ -d ".svn" ]; then
		svn info $(parse_svn_repository_root) | awk '/^Revision:/{print $2}'
	fi
}

function parse_svn_branch() {
	if [ -d ".svn" ]; then
		branch=`parse_svn_url | sed -e 's#^'"$(parse_svn_repository_root)"'##g' | awk '{print $1}'`
		if [ -n "${branch}" ]; then
			echo "$branch"
		else
			echo "none"
		fi
	fi
}

function parse_svn_revisions_behind() {
	# shows how many commits behind remote server
	echo $(parse_svn_revision) $(svnversion) | awk '{print $1 - int($2)}'
}

function parse_svn_dirty() {
	if [ -d ".svn" ]; then
		status=`svn status 2> /dev/null`
		modified=`	echo -n "${status}" 2> /dev/null | grep -q "M				" 2> /dev/null; echo "$?"`
		untracked=` echo -n "${status}" 2> /dev/null | grep -q "?				" 2> /dev/null; echo "$?"`
		newfile=`		echo -n "${status}" 2> /dev/null | grep -q "A				" 2> /dev/null; echo "$?"`
		conflict=`	echo -n "${status}" 2> /dev/null | grep -q "C				" 2> /dev/null; echo "$?"`
		prop_con=`	echo -n "${status}" 2> /dev/null | grep -q " C			" 2> /dev/null; echo "$?"`
		deleted=`		echo -n "${status}" 2> /dev/null | grep -q "D				" 2> /dev/null; echo "$?"`
		replaced=`	echo -n "${status}" 2> /dev/null | grep -q "R				" 2> /dev/null; echo "$?"`
		missing=`		echo -n "${status}" 2> /dev/null | grep -q "!				" 2> /dev/null; echo "$?"`
		rem_lock=`	echo -n "${status}" 2> /dev/null | grep -q "	L			" 2> /dev/null; echo "$?"`
		local_lock=`echo -n "${status}" 2> /dev/null | grep -q "		 K	" 2> /dev/null; echo "$?"`
		lock_del=`	echo -n "${status}" 2> /dev/null | grep -q "D		 K	" 2> /dev/null; echo "$?"`
		switch=`		echo -n "${status}" 2> /dev/null | grep -q "		S		" 2> /dev/null; echo "$?"`
		changed=`		echo -n "${status}" 2> /dev/null | grep -q "~				" 2> /dev/null; echo "$?"`
		bits=""
		if [ "${modified}" == "0" ]; then
						bits="${bits}☭"
		fi
		if [ "${untracked}" == "0" ]; then
						bits="${bits}?"
		fi
		if [ "${newfile}" == "0" ]; then
						bits="${bits}*"
		fi
		if [ "${conflict}" == "0" ]; then
						bits="${bits}<<"
		fi
		if [ "${prop_con}" == "0" ]; then
						bits="${bits}>>"
		fi
		if [ "${deleted}" == "0" ]; then
						bits="${bits}D"
		fi
		if [ "${replaced}" == "0" ]; then
						bits="${bits}%"
		fi
		if [ "${missing}" == "0" ]; then
						bits="${bits}?"
		fi
		if [ "${rem_lock}" == "0" ]; then
						bits="${bits}RL"
		fi
		if [ "${local_lock}" == "0" ]; then
						bits="${bits}L"
		fi
		if [ "${lock_del}" == "0" ]; then
						bits="${bits}ÐL"
		fi
		if [ "${bits}" != "" ]; then
						bits=":${bits}"
		fi
		echo "${bits}"
	fi
}

function parse_git_dirty() {
		status=`git status 2> /dev/null`
		dirty=`		 echo -n "${status}" 2> /dev/null | grep -q "Changed but not updated" 2> /dev/null; echo "$?"`
		untracked=`echo -n "${status}" 2> /dev/null | grep -q "Untracked files" 2> /dev/null; echo "$?"`
		ahead=`		 echo -n "${status}" 2> /dev/null | grep -q "Your branch is ahead of" 2> /dev/null; echo "$?"`
		newfile=`	 echo -n "${status}" 2> /dev/null | grep -q "new file:" 2> /dev/null; echo "$?"`
		renamed=`	 echo -n "${status}" 2> /dev/null | grep -q "renamed:" 2> /dev/null; echo "$?"`
		bits=''
		if [ "${dirty}" == "0" ]; then
					bits="${bits}☭"
		fi
		if [ "${untracked}" == "0" ]; then
					bits="${bits}?"
		fi
		if [ "${newfile}" == "0" ]; then
					bits="${bits}*"
		fi
		if [ "${ahead}" == "0" ]; then
					bits="${bits}+"
		fi
		if [ "${renamed}" == "0" ]; then
					bits="${bits}>"
		fi
		echo "${bits}"
}

function parse_git_svn_revision() {
		ref1=$(__git_ps1 | sed -e "s/ (\(.*\))/(git:\1$(parse_git_dirty))/")
		
		#ref1=$(parse_git_branch)

		if [ "x$ref1" != "x"	]; then
			ref2=$(git branch -a | grep git-svn)
			if [ "x$ref2" != "x" ]; then
					ref3=$(git svn info | grep Revision)
					echo " ${ref1}(svn:r"${ref3#Revision: }")"
			else
					echo " ${ref1} "
			fi
		elif [ "`svnversion`" != "exported"	 ];then 
			echo "(svn:`parse_svn_branch``parse_svn_dirty`)"
		fi
}

function parse_git_branch() {
	git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/(\1$(parse_git_dirty))/"
}
function rvm-prompt-wrapper () {
	[ -a "$HOME/.rvm/bin/rvm-prompt" ] && echo "[$($HOME/.rvm/bin/rvm-prompt s i v p g)]"
}

#\$(__git_ps1 \"(%s)\")\$(parse_svn_branch)
export PS1="\[$COLOR_RED\]\$(rvm-prompt-wrapper)\[$COLOR_GREEN\]\W\[$COLOR_BROWN\]\$(parse_git_svn_revision)\[$COLOR_NC\]→ "

export PS2='>'	 # Secondary prompt
export PS3='?'	 # Prompt 3
export PS4='+'	 # Prompt 4

# This runs before the prompt and sets the title of the xterm* window.	If you set the title in the prompt
# weird wrapping errors occur on some systems, so this method is superior
# Turn this off of you are running directly in the console on the machine
# Set to show current working directory, user, hostname
export PROMPT_COMMAND='echo -ne "\033]0;${PWD##*/} - ${USER}@${HOSTNAME%%.*}"; echo -ne "\007";'$PROMPT_COMMAND
